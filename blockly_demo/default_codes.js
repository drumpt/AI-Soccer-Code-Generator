var DEFAULT_GK = 
'angle = defense_angle\n'
+ 'protection_radius = self.goal_area[Y] / 2 - 0.1\n'
+ 'if helper.ball_is_own_goal((predicted_ball), (self.field), (self.goal_area)):\n'
+ '    x = math.cos(angle) * protection_radius - self.field[X] / 2\n'
+ '    y = math.sin(angle) * protection_radius\n'
+ 'elif helper.ball_is_own_penalty((predicted_ball), (self.field), (self.penalty_area)):\n'
+ '    x = math.cos(angle) * protection_radius - self.field[X] / 2\n'
+ '    y = math.sin(angle) * protection_radius\n'
+ 'elif helper.ball_is_own_field((predicted_ball)):\n'
+ '    x = math.cos(angle) * protection_radius - self.field[X] / 2\n'
+ '    y = math.sin(angle) * protection_radius\n'
+ 'elif helper.ball_is_opp_goal((predicted_ball), (self.field), (self.goal_area)):\n'
+ '    x = math.cos(angle) * protection_radius - self.field[X] / 2\n'
+ '    y = math.sin(angle) * protection_radius\n'
+ 'elif helper.ball_is_opp_penalty((predicted_ball), (self.field), (self.penalty_area)):\n'
+ '    x = math.cos(angle) * protection_radius - self.field[X] / 2\n'
+ '    y = math.sin(angle) * protection_radius\n'
+ 'else:\n'
+ '    x = math.cos(angle) * protection_radius - self.field[X] / 2\n'
+ '    y = math.sin(angle) * protection_radius\n'

var DEFAULT_D1 =
'ox = 0\n'
+ 'min_x = -self.field[X] / 2 + self.goal_area[X]\n'
+ 'min_y = self.goal_area[Y] / 2\n'
+ '\n'
+ 'if helper.ball_is_own_goal(predicted_ball, self.field, self.goal_area):\n'
+ '    mult = 1\n'
+ '    if predicted_ball[Y] < 0:\n'
+ '        mult = -mult\n'
+ '    x = min_x + ox\n'
+ '    y = predicted_ball[Y] + mult * self.robot_size\n'
+ '    angle = defense_angle\n'
+ 'elif helper.ball_is_own_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '    x = max(min_x + ox, predicted_ball[X])\n'
+ '    y = predicted_ball[Y]\n'
+ '    angle = defense_angle\n'
+ 'elif helper.ball_is_own_field(predicted_ball):\n'
+ '    if (robot_id == idx):\n'
+ '        x = predicted_ball[X]\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = defense_angle\n'
+ '    else:\n'
+ '        # Protection agains kicks\n'
+ '        angle = defense_angle\n'
+ '        protection_radius = 1.2\n'
+ '        x = math.cos(angle) * protection_radius - self.field[X] / 2\n'
+ '        y = math.sin(angle) * protection_radius + 0\n'
+ 'elif helper.ball_is_opp_goal(predicted_ball, self.field, self.goal_area):\n'
+ '    if (robot_id == idx):\n'
+ '        x = self.field[X]/2 - self.penalty_area[Y] - 0.2\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = attack_angle			\n'
+ '    else:\n'
+ '        x = cur_ball[X] - 1\n'
+ '        if (cur_ball[Y] > 0):\n'
+ '            y = min(cur_ball[Y], 2.0)\n'
+ '        else:\n'
+ '            y = min(cur_ball[Y], -2.0)\n'
+ 'elif helper.ball_is_opp_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '    if (robot_id == idx):\n'
+ '        x = self.field[X]/2 - self.penalty_area[Y] - 0.2\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = attack_angle			\n'
+ '    else:\n'
+ '        x = cur_ball[X] - 1\n'
+ '        if (cur_ball[Y] > 0):\n'
+ '            y = min(cur_ball[Y], 2.0)\n'
+ '        else:\n'
+ '            y = min(cur_ball[Y], -2.0)\n'
+ 'else: # ball is opp field\n'
+ '    if (robot_id == idx):\n'
+ '        x = predicted_ball[X]\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = defense_angle\n'
+ '    else:\n'
+ '        x = cur_ball[X] - 1\n'
+ '        if (cur_ball[Y] > 0):\n'
+ '            y = min(cur_ball[Y], 2.0)\n'
+ '        else:\n'
+ '            y = max(cur_ball[Y], -2.0)\n'
+ '    angle = attack_angle\n'

var DEFAULT_D2 = 
'ox = 0\n'
+ 'min_x = -self.field[X] / 2 + self.goal_area[X]\n'
+ 'min_y = self.goal_area[Y] / 2\n'
+ 'ball_dist = helper.distance(cur_posture[robot_id][X], cur_ball[X], cur_posture[robot_id][Y],\n'
+ '                                    cur_ball[Y])\n'
+ '\n'
+ 'if helper.ball_is_own_goal(predicted_ball, self.field, self.goal_area):\n'
+ '    mult = -1\n'
+ '    if predicted_ball[Y] < 0:\n'
+ '        mult = -mult\n'
+ '    x = min_x + ox\n'
+ '    y = predicted_ball[Y] + mult * self.robot_size\n'
+ '    angle = defense_angle\n'
+ 'elif helper.ball_is_own_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '    if (-min_y < predicted_ball[Y] < min_y):\n'
+ '        x = predicted_ball[X]\n'
+ '    else:\n'
+ '        x = max(min_x + ox, predicted_ball[X])\n'
+ '    if (robot_id == idx):\n'
+ '        y = predicted_ball[Y]\n'
+ '    else:\n'
+ '        y = predicted_ball[Y] - 0.3  # cafu\n'
+ '    angle = defense_angle\n'
+ 'elif helper.ball_is_own_field(predicted_ball):\n'
+ '    angle = defense_angle\n'
+ '    # in front of the ball\n'
+ '    if (cur_posture[robot_id][X] > predicted_ball[X]):\n'
+ '        if (robot_id == idx or idx == 0):\n'
+ '            x = -math.cos(angle) * 0.1 + predicted_ball[X]\n'
+ '            y = -math.sin(angle) * 0.1 + predicted_ball[Y]  # arrumar\n'
+ '        else:\n'
+ '            x = max(cur_ball[X] - 0.5, min_x)\n'
+ '            y = ((cur_ball[Y] + 0.4) if (cur_posture[robot_id][Y] < 0) else (0))\n'
+ '    # behind the ball\n'
+ '    else:\n'
+ '        if (robot_id == idx or idx == 0):\n'
+ '            if (ball_dist < 0.1 and cur_posture[robot_id][Y] < -1.25 and cur_ball[Y] < -1.25):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            elif (ball_dist < 0.1 and cur_posture[robot_id][Y] > 1.25 and cur_ball[Y] > 1.25):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            else:\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '        else:\n'
+ '            x = max(cur_ball[X] - 0.5, min_x)\n'
+ '            y = ((cur_ball[Y] + 0.4) if (cur_posture[robot_id][Y] < 0) else (0))\n'
+ 'elif helper.ball_is_opp_goal(predicted_ball, self.field, self.goal_area):\n'
+ '    if (robot_id == idx):\n'
+ '        x = self.field[X]/2 - self.penalty_area[Y] - 0.1\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = attack_angle\n'
+ '    else:\n'
+ '        x = cur_ball[X] - self.penalty_area[X]\n'
+ '        y = ((cur_ball[Y]+0.7) if (cur_posture[robot_id][Y]<0) else (0))\n'
+ '        angle = attack_angle\n'
+ 'elif helper.ball_is_opp_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '    if (robot_id == idx):\n'
+ '        x = self.field[X]/2 - self.penalty_area[Y] - 0.1\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = attack_angle\n'
+ '    else:\n'
+ '        x = cur_ball[X] - self.penalty_area[X]\n'
+ '        y = ((cur_ball[Y]+0.7) if (cur_posture[robot_id][Y]<0) else (0))\n'
+ '        angle = attack_angle\n'
+ 'else: # ball is opp field\n'
+ '        if (robot_id == idx):\n'
+ '            if (ball_dist < 0.1 and cur_posture[robot_id][Y] < -2 and cur_ball[Y] < -2):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            elif (ball_dist < 0.1 and cur_posture[robot_id][Y] > 2 and cur_ball[Y] > 2):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            else:\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '        else:\n'
+ '            x = cur_ball[X] - self.penalty_area[X]\n'
+ '            y = ((cur_ball[Y] + 0.7) if (cur_posture[robot_id][Y] < 0) else (0))\n'

var DEFAULT_F1 =
'ox = 0\n'
+ 'min_x = -self.field[X] / 2 + self.penalty_area[X]\n'
+ 'min_y = self.penalty_area[Y] / 2\n'
+ 'ball_dist = helper.distance(cur_posture[robot_id][X], cur_ball[X], cur_posture[robot_id][Y],\n'
+ '                                    cur_ball[Y])\n'
+ '\n'
+ 'if helper.ball_is_own_goal(predicted_ball, self.field, self.goal_area):\n'
+ '    mult = 1\n'
+ '    if predicted_ball[Y] < 0:\n'
+ '        mult = -mult\n'
+ '    x = min_x + ox + 0.4\n'
+ '    y = predicted_ball[Y] + mult * self.robot_size\n'
+ '    angle = defense_angle\n'
+ 'elif helper.ball_is_own_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '    if (-min_y < predicted_ball[Y] < min_y):\n'
+ '        x = min_x + ox + 0.4\n'
+ '    else:\n'
+ '        x = min_x + ox + 0.4\n'
+ '    if (robot_id == idx):\n'
+ '        y = predicted_ball[Y]\n'
+ '    else:\n'
+ '        y = predicted_ball[Y] - 0.2\n'
+ '    angle = defense_angle\n'
+ 'elif helper.ball_is_own_field(predicted_ball):\n'
+ '    angle = defense_angle\n'
+ '    # in front of the ball\n'
+ '    if (cur_posture[robot_id][X] > predicted_ball[X]):\n'
+ '        if (robot_id == idx or idx == 0):\n'
+ '            x = -math.cos(angle) * 0.1 + predicted_ball[X]\n'
+ '            y = -math.sin(angle) * 0.1 + predicted_ball[Y]  # arrumar\n'
+ '        else:\n'
+ '            x = max(cur_ball[X] - 0.5, min_x)\n'
+ '            y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (0))\n'
+ '    # behind the ball\n'
+ '    else:\n'
+ '        if (robot_id == idx or idx == 0):\n'
+ '            if (ball_dist < 0.1 and cur_posture[robot_id][Y] > 2 and cur_ball[Y] > 2):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            elif (ball_dist < 0.1 and cur_posture[robot_id][Y] < -2 and cur_ball[Y] < -2):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            else:\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '        else:\n'
+ '            x = max(cur_ball[X] - 0.5, min_x)\n'
+ '            y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (0))\n'
+ 'elif helper.ball_is_opp_goal(predicted_ball, self.field, self.goal_area):\n'
+ '    if (robot_id == idx):\n'
+ '        x = predicted_ball[X]\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = attack_angle\n'
+ '    else:\n'
+ '        x = cur_ball[X] - 0.15\n'
+ '        y = self.goal[Y] / 2\n'
+ '        angle = attack_angle\n'
+ 'elif helper.ball_is_opp_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '    if (robot_id == idx):\n'
+ '        x = predicted_ball[X]\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = attack_angle\n'
+ '    else:\n'
+ '        x = cur_ball[X] - 0.15\n'
+ '        y = self.goal[Y] / 2\n'
+ '        angle = attack_angle\n'
+ 'else: # ball is opp field\n'
+ '    angle = attack_angle\n'
+ '    # in front of the ball\n'
+ '    if (cur_posture[robot_id][X] > predicted_ball[X]):\n'
+ '        if (robot_id == idx):\n'
+ '            x = -math.cos(angle) * 0.1 + predicted_ball[X]\n'
+ '            y = math.sin(angle) * 0.1 + predicted_ball[Y]  # arrumar\n'
+ '        else:\n'
+ '            x = max(cur_ball[X] - 0.5, min_x)\n'
+ '            y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (0))\n'
+ '    # behind the ball\n'
+ '    else:\n'
+ '        if (robot_id == idx):\n'
+ '            if (ball_dist < 0.1 and cur_posture[robot_id][Y] > 2 and cur_ball[Y] > 2):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            elif (ball_dist < 0.1 and cur_posture[robot_id][Y] < -2 and cur_ball[Y] < -2):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            else:\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '        else:\n'
+ '            x = max(cur_ball[X] - 0.5, min_x)\n'
+ '            y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (0))\n'

var DEFAULT_F2 =
'ox = 0\n'
+ 'min_x = -self.field[X] / 2 + self.penalty_area[X]\n'
+ 'ball_dist = helper.distance(cur_posture[robot_id][X], cur_ball[X], cur_posture[robot_id][Y],\n'
+ '                                    cur_ball[Y])\n'
+ '\n'
+ 'if helper.ball_is_own_goal(predicted_ball, self.field, self.goal_area):\n'
+ '    x = 0\n'
+ '    y = max(min(cur_ball[Y] + 0.3, 1.5), -1.1)\n'
+ 'elif helper.ball_is_own_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '    x = 0\n'
+ '    y = max(min(cur_ball[Y] + 0.3, 1.5), -1.1)\n'
+ 'elif helper.ball_is_own_field(predicted_ball):\n'
+ '    x = 0\n'
+ '    y = max(min(cur_ball[Y] + 0.3, 1.5), -1.1)\n'
+ 'elif helper.ball_is_opp_goal(predicted_ball, self.field, self.goal_area):\n'
+ '    if (robot_id == idx):\n'
+ '        x = predicted_ball[X]\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = attack_angle\n'
+ '    else:\n'
+ '        x = cur_ball[X] - 0.15\n'
+ '        y = 0\n'
+ '        angle = attack_angle\n'
+ 'elif helper.ball_is_opp_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '    if (robot_id == idx):\n'
+ '        x = predicted_ball[X]\n'
+ '        y = predicted_ball[Y]\n'
+ '        angle = attack_angle\n'
+ '    else:\n'
+ '        x = cur_ball[X] - 0.15\n'
+ '        y = 0\n'
+ '        angle = attack_angle\n'
+ 'else: # ball is opp field\n'
+ '    angle = attack_angle\n'
+ '    # in front of the ball\n'
+ '    if (cur_posture[robot_id][X] > predicted_ball[X]):\n'
+ '        if (robot_id == idx):\n'
+ '            x = -math.cos(angle) * 0.1 + predicted_ball[X]\n'
+ '            y = math.sin(angle) * 0.1 + predicted_ball[Y]  # arrumar\n'
+ '        else:\n'
+ '            x = max(cur_ball[X] - 0.5, min_x)\n'
+ '            y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (cur_ball[Y] + 0.7))\n'
+ '    # behind the ball\n'
+ '    else:\n'
+ '        if (robot_id == idx):\n'
+ '            if (ball_dist < 0.1 and cur_posture[robot_id][Y] < -2 and cur_ball[Y] < -2):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            elif (ball_dist < 0.1 and cur_posture[robot_id][Y] > 2 and cur_ball[Y] > 2):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = predicted_ball[Y]\n'
+ '            elif (ball_dist < 0.05):\n'
+ '                x = self.field[X] / 2\n'
+ '                y = 0\n'
+ '            else:\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '        else:\n'
+ '            x = max(cur_ball[X] - 0.5, min_x)\n'
+ '            y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (cur_ball[Y] + 0.7))\n'