var PLAYERS_P1 = 
'#!/usr/bin/python3\n'
+ '\n'
+ '# File: players.py\n'
+ '# Date: February 03, 2019\n'
+ '# Description: Player functions for the Robot Soccer Strategy App\n'
+ '# Author(s): Luiz Felipe Vecchietti\n'
+ '\n'
+ 'import math\n'
+ '\n'
+ 'import helper\n'
+ '\n'
+ '#reset_reason\n'
+ 'NONE = 0\n'
+ 'GAME_START = 1\n'
+ 'SCORE_MYTEAM = 2\n'
+ 'SCORE_OPPONENT = 3\n'
+ 'GAME_END = 4\n'
+ 'DEADLOCK = 5\n'
+ 'GOALKICK = 6\n'
+ 'CORNERKICK = 7\n'
+ 'PENALTYKICK = 8\n'
+ 'HALFTIME = 9\n'
+ 'EPISODE_END = 10\n'
+ '\n'
+ '#game_state\n'
+ 'STATE_DEFAULT = 0\n'
+ 'STATE_BACKPASS = 1\n'
+ 'STATE_GOALKICK = 2\n'
+ 'STATE_CORNERKICK = 3\n'
+ 'STATE_PENALTYKICK = 4\n'
+ '\n'
+ '#coordinates\n'
+ 'MY_TEAM = 0\n'
+ 'OP_TEAM = 1\n'
+ 'BALL = 2\n'
+ 'X = 0\n'
+ 'Y = 1\n'
+ 'TH = 2\n'
+ 'ACTIVE = 3\n'
+ 'TOUCH = 4\n'
+ '\n'
+ 'class Goalkeeper:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, defense_angle, cur_posture, cur_ball, predicted_ball):\n';

var PLAYERS_P2 = 
'\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n'
+ '\n'
+ 'class Defender_1:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, idx, defense_angle, attack_angle, cur_posture, cur_ball, predicted_ball):\n';

var PLAYERS_P3 = 
'\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n'
+ '\n'
+ 'class Defender_2:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, idx, defense_angle, attack_angle, cur_posture, cur_ball, predicted_ball):\n';

var PLAYERS_P4 = 
'\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n'
+ '\n'
+ 'class Forward_1:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, idx, defense_angle, attack_angle, cur_posture, cur_ball, predicted_ball):\n';

var PLAYERS_P5 = 
'\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n'
+ '\n'
+ 'class Forward_2:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, idx, idx_opp, defense_angle, attack_angle, cur_posture, cur_posture_opp, cur_ball, predicted_ball):\n';

var PLAYERS_P6 = 
'\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n';