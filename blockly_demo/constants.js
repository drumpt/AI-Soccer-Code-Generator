var PLAYERS_P1 = 
'#!/usr/bin/python3\n'
+ '\n'
+ '# File: players.py\n'
+ '# Date: February 03, 2019\n'
+ '# Description: Player functions for the Robot Soccer Strategy App\n'
+ '# Author(s): Luiz Felipe Vecchietti\n'
+ '\n'
+ 'import math\n'
+ '\n'
+ 'import helper\n'
+ '\n'
+ '#reset_reason\n'
+ 'NONE = 0\n'
+ 'GAME_START = 1\n'
+ 'SCORE_MYTEAM = 2\n'
+ 'SCORE_OPPONENT = 3\n'
+ 'GAME_END = 4\n'
+ 'DEADLOCK = 5\n'
+ 'GOALKICK = 6\n'
+ 'CORNERKICK = 7\n'
+ 'PENALTYKICK = 8\n'
+ 'HALFTIME = 9\n'
+ 'EPISODE_END = 10\n'
+ '\n'
+ '#game_state\n'
+ 'STATE_DEFAULT = 0\n'
+ 'STATE_BACKPASS = 1\n'
+ 'STATE_GOALKICK = 2\n'
+ 'STATE_CORNERKICK = 3\n'
+ 'STATE_PENALTYKICK = 4\n'
+ '\n'
+ '#coordinates\n'
+ 'MY_TEAM = 0\n'
+ 'OP_TEAM = 1\n'
+ 'BALL = 2\n'
+ 'X = 0\n'
+ 'Y = 1\n'
+ 'TH = 2\n'
+ 'ACTIVE = 3\n'
+ 'TOUCH = 4\n'
+ '\n'
+ 'class Goalkeeper:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, defense_angle, cur_posture, cur_ball, predicted_ball):\n';

var PLAYERS_P2 = 
'\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n'
+ '\n'
+ 'class Defender_1:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, idx, defense_angle, attack_angle, cur_posture, cur_ball, predicted_ball):\n'
+ '        ox = 0\n'
+ '        min_x = -self.field[X] / 2 + self.goal_area[X]\n'
+ '        min_y = self.goal_area[Y] / 2\n'
+ '\n'
+ '        if helper.ball_is_own_goal(predicted_ball, self.field, self.goal_area):\n'
+ '            mult = 1\n'
+ '            if predicted_ball[Y] < 0:\n'
+ '                mult = -mult\n'
+ '            x = min_x + ox\n'
+ '            y = predicted_ball[Y] + mult * self.robot_size\n'
+ '            angle = defense_angle\n'
+ '        elif helper.ball_is_own_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '            x = max(min_x + ox, predicted_ball[X])\n'
+ '            y = predicted_ball[Y]\n'
+ '            angle = defense_angle\n'
+ '        elif helper.ball_is_own_field(predicted_ball):\n'
+ '            if (robot_id == idx):\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = defense_angle\n'
+ '            else:\n'
+ '                # Protection agains kicks\n'
+ '                angle = defense_angle\n'
+ '                protection_radius = 1.2\n'
+ '                x = math.cos(angle) * protection_radius - self.field[X] / 2\n'
+ '                y = math.sin(angle) * protection_radius + 0\n'
+ '        elif helper.ball_is_opp_goal(predicted_ball, self.field, self.goal_area):\n'
+ '            if (robot_id == idx):\n'
+ '                x = self.field[X]/2 - self.penalty_area[Y] - 0.2\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = attack_angle			\n'
+ '            else:\n'
+ '                x = cur_ball[X] - 1\n'
+ '                if (cur_ball[Y] > 0):\n'
+ '                    y = min(cur_ball[Y], 2.0)\n'
+ '                else:\n'
+ '                    y = min(cur_ball[Y], -2.0)\n'
+ '        elif helper.ball_is_opp_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '            if (robot_id == idx):\n'
+ '                x = self.field[X]/2 - self.penalty_area[Y] - 0.2\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = attack_angle			\n'
+ '            else:\n'
+ '                x = cur_ball[X] - 1\n'
+ '                if (cur_ball[Y] > 0):\n'
+ '                    y = min(cur_ball[Y], 2.0)\n'
+ '                else:\n'
+ '                    y = min(cur_ball[Y], -2.0)\n'
+ '        else: # ball is opp field\n'
+ '            if (robot_id == idx):\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = defense_angle\n'
+ '            else:\n'
+ '                x = cur_ball[X] - 1\n'
+ '                if (cur_ball[Y] > 0):\n'
+ '                    y = min(cur_ball[Y], 2.0)\n'
+ '                else:\n'
+ '                    y = max(cur_ball[Y], -2.0)\n'
+ '            angle = attack_angle\n'
+ '\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n'
+ '\n'
+ 'class Defender_2:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, idx, defense_angle, attack_angle, cur_posture, cur_ball, predicted_ball):\n'
+ '        ox = 0\n'
+ '        min_x = -self.field[X] / 2 + self.goal_area[X]\n'
+ '        min_y = self.goal_area[Y] / 2\n'
+ '        ball_dist = helper.distance(cur_posture[robot_id][X], cur_ball[X], cur_posture[robot_id][Y],\n'
+ '                                    cur_ball[Y])\n'
+ '\n'
+ '        if helper.ball_is_own_goal(predicted_ball, self.field, self.goal_area):\n'
+ '            mult = -1\n'
+ '            if predicted_ball[Y] < 0:\n'
+ '                mult = -mult\n'
+ '            x = min_x + ox\n'
+ '            y = predicted_ball[Y] + mult * self.robot_size\n'
+ '            angle = defense_angle\n'
+ '        elif helper.ball_is_own_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '            if (-min_y < predicted_ball[Y] < min_y):\n'
+ '                x = predicted_ball[X]\n'
+ '            else:\n'
+ '                x = max(min_x + ox, predicted_ball[X])\n'
+ '            if (robot_id == idx):\n'
+ '                y = predicted_ball[Y]\n'
+ '            else:\n'
+ '                y = predicted_ball[Y] - 0.3  # cafu\n'
+ '            angle = defense_angle\n'
+ '        elif helper.ball_is_own_field(predicted_ball):\n'
+ '            angle = defense_angle\n'
+ '            # in front of the ball\n'
+ '            if (cur_posture[robot_id][X] > predicted_ball[X]):\n'
+ '                if (robot_id == idx or idx == 0):\n'
+ '                    x = -math.cos(angle) * 0.1 + predicted_ball[X]\n'
+ '                    y = -math.sin(angle) * 0.1 + predicted_ball[Y]  # arrumar\n'
+ '                else:\n'
+ '                    x = max(cur_ball[X] - 0.5, min_x)\n'
+ '                    y = ((cur_ball[Y] + 0.4) if (cur_posture[robot_id][Y] < 0) else (0))\n'
+ '            # behind the ball\n'
+ '            else:\n'
+ '                if (robot_id == idx or idx == 0):\n'
+ '                    if (ball_dist < 0.1 and cur_posture[robot_id][Y] < -1.25 and cur_ball[Y] < -1.25):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    elif (ball_dist < 0.1 and cur_posture[robot_id][Y] > 1.25 and cur_ball[Y] > 1.25):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    else:\n'
+ '                        x = predicted_ball[X]\n'
+ '                        y = predicted_ball[Y]\n'
+ '                else:\n'
+ '                    x = max(cur_ball[X] - 0.5, min_x)\n'
+ '                    y = ((cur_ball[Y] + 0.4) if (cur_posture[robot_id][Y] < 0) else (0))\n'
+ '        elif helper.ball_is_opp_goal(predicted_ball, self.field, self.goal_area):\n'
+ '            if (robot_id == idx):\n'
+ '                x = self.field[X]/2 - self.penalty_area[Y] - 0.1\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = attack_angle\n'
+ '            else:\n'
+ '                x = cur_ball[X] - self.penalty_area[X]\n'
+ '                y = ((cur_ball[Y]+0.7) if (cur_posture[robot_id][Y]<0) else (0))\n'
+ '                angle = attack_angle\n'
+ '        elif helper.ball_is_opp_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '            if (robot_id == idx):\n'
+ '                x = self.field[X]/2 - self.penalty_area[Y] - 0.1\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = attack_angle\n'
+ '            else:\n'
+ '                x = cur_ball[X] - self.penalty_area[X]\n'
+ '                y = ((cur_ball[Y]+0.7) if (cur_posture[robot_id][Y]<0) else (0))\n'
+ '                angle = attack_angle\n'
+ '        else: # ball is opp field\n'
+ '                if (robot_id == idx):\n'
+ '                    if (ball_dist < 0.1 and cur_posture[robot_id][Y] < -2 and cur_ball[Y] < -2):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    elif (ball_dist < 0.1 and cur_posture[robot_id][Y] > 2 and cur_ball[Y] > 2):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    else:\n'
+ '                        x = predicted_ball[X]\n'
+ '                        y = predicted_ball[Y]\n'
+ '                else:\n'
+ '                    x = cur_ball[X] - self.penalty_area[X]\n'
+ '                    y = ((cur_ball[Y] + 0.7) if (cur_posture[robot_id][Y] < 0) else (0))\n'
+ '\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n'
+ '\n'
+ 'class Forward_1:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, idx, defense_angle, attack_angle, cur_posture, cur_ball, predicted_ball):\n'
+ '        ox = 0\n'
+ '        min_x = -self.field[X] / 2 + self.penalty_area[X]\n'
+ '        min_y = self.penalty_area[Y] / 2\n'
+ '        ball_dist = helper.distance(cur_posture[robot_id][X], cur_ball[X], cur_posture[robot_id][Y],\n'
+ '                                    cur_ball[Y])\n'
+ '\n'
+ '        if helper.ball_is_own_goal(predicted_ball, self.field, self.goal_area):\n'
+ '            mult = 1\n'
+ '            if predicted_ball[Y] < 0:\n'
+ '                mult = -mult\n'
+ '            x = min_x + ox + 0.4\n'
+ '            y = predicted_ball[Y] + mult * self.robot_size\n'
+ '            angle = defense_angle\n'
+ '        elif helper.ball_is_own_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '            if (-min_y < predicted_ball[Y] < min_y):\n'
+ '                x = min_x + ox + 0.4\n'
+ '            else:\n'
+ '                x = min_x + ox + 0.4\n'
+ '            if (robot_id == idx):\n'
+ '                y = predicted_ball[Y]\n'
+ '            else:\n'
+ '                y = predicted_ball[Y] - 0.2\n'
+ '            angle = defense_angle\n'
+ '        elif helper.ball_is_own_field(predicted_ball):\n'
+ '            angle = defense_angle\n'
+ '            # in front of the ball\n'
+ '            if (cur_posture[robot_id][X] > predicted_ball[X]):\n'
+ '                if (robot_id == idx or idx == 0):\n'
+ '                    x = -math.cos(angle) * 0.1 + predicted_ball[X]\n'
+ '                    y = -math.sin(angle) * 0.1 + predicted_ball[Y]  # arrumar\n'
+ '                else:\n'
+ '                    x = max(cur_ball[X] - 0.5, min_x)\n'
+ '                    y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (0))\n'
+ '            # behind the ball\n'
+ '            else:\n'
+ '                if (robot_id == idx or idx == 0):\n'
+ '                    if (ball_dist < 0.1 and cur_posture[robot_id][Y] > 2 and cur_ball[Y] > 2):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    elif (ball_dist < 0.1 and cur_posture[robot_id][Y] < -2 and cur_ball[Y] < -2):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    else:\n'
+ '                        x = predicted_ball[X]\n'
+ '                        y = predicted_ball[Y]\n'
+ '                else:\n'
+ '                    x = max(cur_ball[X] - 0.5, min_x)\n'
+ '                    y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (0))\n'
+ '        elif helper.ball_is_opp_goal(predicted_ball, self.field, self.goal_area):\n'
+ '            if (robot_id == idx):\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = attack_angle\n'
+ '            else:\n'
+ '                x = cur_ball[X] - 0.15\n'
+ '                y = self.goal[Y] / 2\n'
+ '                angle = attack_angle\n'
+ '        elif helper.ball_is_opp_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '            if (robot_id == idx):\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = attack_angle\n'
+ '            else:\n'
+ '                x = cur_ball[X] - 0.15\n'
+ '                y = self.goal[Y] / 2\n'
+ '                angle = attack_angle\n'
+ '        else: # ball is opp field\n'
+ '            angle = attack_angle\n'
+ '            # in front of the ball\n'
+ '            if (cur_posture[robot_id][X] > predicted_ball[X]):\n'
+ '                if (robot_id == idx):\n'
+ '                    x = -math.cos(angle) * 0.1 + predicted_ball[X]\n'
+ '                    y = math.sin(angle) * 0.1 + predicted_ball[Y]  # arrumar\n'
+ '                else:\n'
+ '                    x = max(cur_ball[X] - 0.5, min_x)\n'
+ '                    y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (0))\n'
+ '            # behind the ball\n'
+ '            else:\n'
+ '                if (robot_id == idx):\n'
+ '                    if (ball_dist < 0.1 and cur_posture[robot_id][Y] > 2 and cur_ball[Y] > 2):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    elif (ball_dist < 0.1 and cur_posture[robot_id][Y] < -2 and cur_ball[Y] < -2):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    else:\n'
+ '                        x = predicted_ball[X]\n'
+ '                        y = predicted_ball[Y]\n'
+ '                else:\n'
+ '                    x = max(cur_ball[X] - 0.5, min_x)\n'
+ '                    y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (0))\n'
+ '\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n'
+ '\n'
+ 'class Forward_2:\n'
+ '\n'
+ '    def __init__(self, field, goal, penalty_area, goal_area, robot_size, max_linear_velocity):\n'
+ '        self.field = field\n'
+ '        self.goal = goal\n'
+ '        self.penalty_area = penalty_area\n'
+ '        self.goal_area = goal_area\n'
+ '        self.robot_size = robot_size\n'
+ '        self.max_linear_velocity = max_linear_velocity\n'
+ '\n'
+ '    def go_to(self, robot_id, x, y, cur_posture, cur_ball):\n'
+ '        damping = 0.35\n'
+ '        mult_lin = 3.5\n'
+ '        mult_ang = 0.4\n'
+ '        ka = 0.21\n'
+ '        sign = 1\n'
+ '\n'
+ '        dx = x - cur_posture[robot_id][X]\n'
+ '        dy = y - cur_posture[robot_id][Y]\n'
+ '        d_e = math.sqrt(math.pow(dx, 2) + math.pow(dy, 2))\n'
+ '        desired_th = (math.pi / 2) if (dx == 0 and dy == 0) else math.atan2(dy, dx)\n'
+ '\n'
+ '        if (cur_posture[robot_id][TH] > math.pi):\n'
+ '            th = cur_posture[robot_id][TH] - 2 * math.pi\n'
+ '        else:\n'
+ '            th = cur_posture[robot_id][TH]\n'
+ '\n'
+ '        d_th = desired_th - th\n'
+ '        while (d_th > math.pi):\n'
+ '            d_th -= 2 * math.pi\n'
+ '        while (d_th < -math.pi):\n'
+ '            d_th += 2 * math.pi\n'
+ '        \n'
+ '        if (d_th > helper.degree2radian(95)):\n'
+ '            d_th -= math.pi\n'
+ '            sign = -1\n'
+ '        elif (d_th < helper.degree2radian(-95)):\n'
+ '            d_th += math.pi\n'
+ '            sign = -1\n'
+ '\n'
+ '        if (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] <= 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                      -mult_ang*d_th,\n'
+ '                                                                       mult_ang*d_th)\n'
+ '        elif (abs(d_th) > helper.degree2radian(85) and cur_ball[Y] > 0):\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                                                                       mult_ang*d_th,\n'
+ '                                                                       -mult_ang*d_th)\n'
+ '        else:\n'
+ '            if (d_e < 5 and abs(d_th) < helper.degree2radian(40)):\n'
+ '                ka = 0.1\n'
+ '            ka *= 4\n'
+ '            left_wheel, right_wheel = helper.set_wheel_velocity(self.max_linear_velocity,\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) - mult_ang * ka * d_th),\n'
+ '                          sign * (mult_lin * (1 / (1 + math.exp(-3*d_e)) - damping) + mult_ang * ka * d_th))\n'
+ '\n'
+ '        return left_wheel, right_wheel\n'
+ '\n'
+ '    def move(self, robot_id, idx, idx_opp, defense_angle, attack_angle, cur_posture, cur_posture_opp, cur_ball, predicted_ball):\n'
+ '        ox = 0\n'
+ '        min_x = -self.field[X] / 2 + self.penalty_area[X]\n'
+ '        ball_dist = helper.distance(cur_posture[robot_id][X], cur_ball[X], cur_posture[robot_id][Y],\n'
+ '                                    cur_ball[Y])\n'
+ '\n'
+ '        if helper.ball_is_own_goal(predicted_ball, self.field, self.goal_area):\n'
+ '            x = 0\n'
+ '            y = max(min(cur_ball[Y] + 0.3, 1.5), -1.1)\n'
+ '        elif helper.ball_is_own_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '            x = 0\n'
+ '            y = max(min(cur_ball[Y] + 0.3, 1.5), -1.1)\n'
+ '        elif helper.ball_is_own_field(predicted_ball):\n'
+ '            x = 0\n'
+ '            y = max(min(cur_ball[Y] + 0.3, 1.5), -1.1)\n'
+ '        elif helper.ball_is_opp_goal(predicted_ball, self.field, self.goal_area):\n'
+ '            if (robot_id == idx):\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = attack_angle\n'
+ '            else:\n'
+ '                x = cur_ball[X] - 0.15\n'
+ '                y = 0\n'
+ '                angle = attack_angle\n'
+ '        elif helper.ball_is_opp_penalty(predicted_ball, self.field, self.penalty_area):\n'
+ '            if (robot_id == idx):\n'
+ '                x = predicted_ball[X]\n'
+ '                y = predicted_ball[Y]\n'
+ '                angle = attack_angle\n'
+ '            else:\n'
+ '                x = cur_ball[X] - 0.15\n'
+ '                y = 0\n'
+ '                angle = attack_angle\n'
+ '        else: # ball is opp field\n'
+ '            angle = attack_angle\n'
+ '            # in front of the ball\n'
+ '            if (cur_posture[robot_id][X] > predicted_ball[X]):\n'
+ '                if (robot_id == idx):\n'
+ '                    x = -math.cos(angle) * 0.1 + predicted_ball[X]\n'
+ '                    y = math.sin(angle) * 0.1 + predicted_ball[Y]  # arrumar\n'
+ '                else:\n'
+ '                    x = max(cur_ball[X] - 0.5, min_x)\n'
+ '                    y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (cur_ball[Y] + 0.7))\n'
+ '            # behind the ball\n'
+ '            else:\n'
+ '                if (robot_id == idx):\n'
+ '                    if (ball_dist < 0.1 and cur_posture[robot_id][Y] < -2 and cur_ball[Y] < -2):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    elif (ball_dist < 0.1 and cur_posture[robot_id][Y] > 2 and cur_ball[Y] > 2):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = predicted_ball[Y]\n'
+ '                    elif (ball_dist < 0.05):\n'
+ '                        x = self.field[X] / 2\n'
+ '                        y = 0\n'
+ '                    else:\n'
+ '                        x = predicted_ball[X]\n'
+ '                        y = predicted_ball[Y]\n'
+ '                else:\n'
+ '                    x = max(cur_ball[X] - 0.5, min_x)\n'
+ '                    y = ((cur_ball[Y] - 0.7) if (cur_posture[robot_id][Y] > 0) else (cur_ball[Y] + 0.7))\n'
+ '\n'
+ '        return self.go_to(robot_id, x, y, cur_posture, cur_ball)\n';